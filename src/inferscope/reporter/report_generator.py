"""
Report Generator

Generates human-readable reports from bottleneck analysis results.
Supports Markdown, HTML, and JSON output formats.
"""

import json
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


class ReportGenerator:
    """
    Generate reports from analysis results and timeline.
    
    Output Formats:
    - Markdown (default, human-readable)
    - HTML (web-viewable)
    - JSON (machine-readable)
    """
    
    def __init__(self, analysis: Dict[str, Any], timeline: Optional[List[Dict[str, Any]]] = None):
        """
        Initialize report generator.
        
        Args:
            analysis: Bottleneck analysis result from BottleneckAnalyzer
            timeline: Optional unified timeline for detailed reports
        """
        self.analysis = analysis
        self.timeline = timeline or []
        self.timestamp = datetime.utcnow().isoformat() + 'Z'
    
    def to_markdown(self) -> str:
        """
        Generate Markdown report.
        
        Returns:
            Markdown-formatted report string
        """
        lines = [
            "# InferScope Performance Report",
            "",
            f"**Generated:** {self.timestamp}",
            "",
            "---",
            "",
        ]
        
        # Summary section
        summary = self.analysis.get('summary', {})
        if summary:
            lines.extend(self._markdown_summary(summary))
        
        # Bottleneck analysis
        bottleneck = self.analysis.get('bottleneck', {})
        if bottleneck:
            lines.extend(self._markdown_bottleneck(bottleneck))
        
        # Timeline breakdown
        breakdown = self.analysis.get('timeline_breakdown', [])
        if breakdown:
            lines.extend(self._markdown_breakdown(breakdown))
        
        # Suggestions
        suggestions = self.analysis.get('suggestions', [])
        if suggestions:
            lines.extend(self._markdown_suggestions(suggestions))
        
        # Footer
        lines.extend([
            "",
            "---",
            "",
            "*Report generated by InferScope v0.1*",
            "",
        ])
        
        return "\n".join(lines)
    
    def _markdown_summary(self, summary: Dict[str, Any]) -> List[str]:
        """Format summary section."""
        end_to_end = summary.get('end_to_end_latency_us', 0)
        cpu_time = summary.get('total_cpu_time_us', 0)
        gpu_time = summary.get('total_gpu_time_us', 0)
        h2d_time = summary.get('total_h2d_us', 0)
        d2h_time = summary.get('total_d2h_us', 0)
        
        return [
            "## Summary",
            "",
            f"**End-to-end latency:** {end_to_end / 1000:.1f} ms",
            "",
            "### Breakdown",
            "",
            f"- CPU time: {cpu_time / 1000:.1f} ms ({100 * cpu_time / end_to_end if end_to_end else 0:.1f}%)",
            f"- GPU time: {gpu_time / 1000:.1f} ms ({100 * gpu_time / end_to_end if end_to_end else 0:.1f}%)",
            f"- H2D copy: {h2d_time / 1000:.1f} ms ({100 * h2d_time / end_to_end if end_to_end else 0:.1f}%)",
            f"- D2H copy: {d2h_time / 1000:.1f} ms ({100 * d2h_time / end_to_end if end_to_end else 0:.1f}%)",
            "",
        ]
    
    def _markdown_bottleneck(self, bottleneck: Dict[str, Any]) -> List[str]:
        """Format bottleneck analysis section."""
        btype = bottleneck.get('type', 'unknown')
        cause = bottleneck.get('primary_cause', 'unknown')
        confidence = bottleneck.get('confidence', 0.0)
        evidence = bottleneck.get('evidence', [])
        
        lines = [
            "## Diagnosis",
            "",
            f"**Bottleneck:** {btype.replace('_', ' ').title()}",
            f"**Primary cause:** {cause.replace('_', ' ')}",
            f"**Confidence:** {confidence * 100:.0f}%",
            "",
        ]
        
        if evidence:
            lines.append("**Evidence:**")
            lines.append("")
            for ev in evidence:
                lines.append(f"- {ev}")
            lines.append("")
        
        return lines
    
    def _markdown_breakdown(self, breakdown: List[Dict[str, Any]]) -> List[str]:
        """Format timeline breakdown table."""
        if not breakdown:
            return []
        
        lines = [
            "## Timeline Breakdown",
            "",
            "| Category | Duration (ms) | Percentage |",
            "|----------|--------------|------------|",
        ]
        
        for item in breakdown:
            cat = item.get('category', 'unknown')
            duration_ms = item.get('duration_us', 0) / 1000
            pct = item.get('percentage', 0.0)
            lines.append(f"| {cat.replace('_', ' ').title()} | {duration_ms:.1f} | {pct:.1f}% |")
        
        lines.append("")
        return lines
    
    def _markdown_suggestions(self, suggestions: List[Dict[str, Any]]) -> List[str]:
        """Format suggestions section."""
        if not suggestions:
            return []
        
        lines = [
            "## Suggestions",
            "",
        ]
        
        for i, sug in enumerate(suggestions, 1):
            priority = sug.get('priority', 'medium')
            action = sug.get('action', 'No action')
            rationale = sug.get('rationale', '')
            impact = sug.get('estimated_improvement_percent', 0)
            
            lines.append(f"### {i}. {action} ({priority} priority)")
            lines.append("")
            if rationale:
                lines.append(f"**Rationale:** {rationale}")
                lines.append("")
            if impact > 0:
                lines.append(f"**Estimated improvement:** {impact}%")
                lines.append("")
        
        return lines
    
    def to_html(self) -> str:
        """
        Generate HTML report.
        
        Returns:
            HTML-formatted report string
        """
        # Simple HTML wrapper around Markdown content
        markdown_body = self.to_markdown()
        
        # Basic conversion: replace headers, lists, bold
        html_body = markdown_body
        html_body = html_body.replace('# ', '<h1>').replace('\n## ', '</h1>\n<h2>').replace('\n### ', '</h2>\n<h3>')
        html_body = html_body.replace('**', '<strong>', 1).replace('**', '</strong>', 1)
        html_body = html_body.replace('- ', '<li>', 1).replace('\n', '</li>\n')
        html_body = html_body.replace('\n\n', '</p><p>')
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>InferScope Performance Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; max-width: 900px; margin: 40px auto; padding: 20px; }}
        h1 {{ color: #2c3e50; }}
        h2 {{ color: #34495e; margin-top: 30px; }}
        h3 {{ color: #7f8c8d; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
        th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
        th {{ background-color: #3498db; color: white; }}
        code {{ background-color: #f4f4f4; padding: 2px 6px; border-radius: 3px; }}
        .priority-high {{ color: #e74c3c; font-weight: bold; }}
        .priority-medium {{ color: #f39c12; }}
        .priority-low {{ color: #95a5a6; }}
    </style>
</head>
<body>
    {html_body}
</body>
</html>
"""
        return html
    
    def to_json(self) -> str:
        """
        Generate JSON report.
        
        Returns:
            JSON-formatted report string
        """
        report = {
            'report_type': 'json',
            'title': 'InferScope Performance Report',
            'timestamp': self.timestamp,
            'analysis': self.analysis,
            'timeline_event_count': len(self.timeline),
        }
        
        return json.dumps(report, indent=2)
    
    def save(self, filepath: str, format: str = 'markdown') -> None:
        """
        Save report to file.
        
        Args:
            filepath: Output file path
            format: Output format ('markdown', 'html', 'json')
        """
        format = format.lower()
        
        if format == 'markdown' or format == 'md':
            content = self.to_markdown()
        elif format == 'html':
            content = self.to_html()
        elif format == 'json':
            content = self.to_json()
        else:
            raise ValueError(f"Unknown format: {format}. Use 'markdown', 'html', or 'json'")
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Report saved to {filepath} ({format} format)")
