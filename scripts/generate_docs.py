#!/usr/bin/env python3
"""
Generate all documentation from YAML sources.

This script consolidates doc generation:
- PRD.md from requirements.yaml
- SAD.md from architecture.yaml
- ICD.md from interfaces.yaml

Ensures single source of truth for requirements, architecture, and interfaces.

Usage:
    python scripts/generate_docs.py
"""

import yaml
from pathlib import Path


def generate_prd(yaml_path: Path, output_path: Path):
    """Generate PRD.md from requirements.yaml"""
    
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)
    
    lines = [
        "<!-- AUTO-GENERATED from requirements.yaml -->",
        "<!-- Do not edit this file directly. Edit requirements.yaml and run: python scripts/generate_docs.py -->",
        "",
        "# Product Requirement Document (PRD)",
        "",
        "## Overview",
        "InferScope is a single-GPU/single-node AI inference bottleneck analysis tool that provides end-to-end timeline visibility and actionable optimization suggestions.",
        "",
        "## Functional Requirements",
        ""
    ]
    
    frs = data.get('functional_requirements', {})
    for fr_id in sorted(frs.keys()):
        fr = frs[fr_id]
        lines.append(f"### {fr_id}: {fr['title']}")
        lines.append(f"- **Description**: {fr['description']}")
        lines.append("- **Acceptance Criteria**: ")
        for criterion in fr.get('acceptance_criteria', []):
            lines.append(f"  - {criterion}")
        lines.append("")
    
    lines.append("## Non-Functional Requirements")
    lines.append("")
    
    nfrs = data.get('non_functional_requirements', {})
    for nfr_id in sorted(nfrs.keys()):
        nfr = nfrs[nfr_id]
        lines.append(f"### {nfr_id}: {nfr['title']}")
        lines.append(f"- **Description**: {nfr['description']}")
        
        if 'metric' in nfr:
            lines.append(f"- **Acceptance Criteria**: {nfr['metric']}")
        elif 'constraint' in nfr:
            lines.append(f"- **Acceptance Criteria**: {nfr['constraint']}")
        elif 'scope' in nfr:
            lines.append(f"- **Acceptance Criteria**: {nfr['scope']}")
        elif 'platforms' in nfr:
            lines.append("- **Acceptance Criteria**: Tested on " + ", ".join(nfr['platforms']))
        
        lines.append("")
    
    lines.extend([
        "## Out-of-Scope",
        "- Model accuracy or algorithm optimization",
        "- Multi-GPU or distributed inference",
        "- Manual kernel tuning or compilation",
        "- Benchmark rankings or comparisons",
        "- Windows or macOS support (MVP)",
    ])
    
    output_path.write_text('\n'.join(lines) + '\n')
    print(f"✓ Generated {output_path.name} from {yaml_path.name}")


def generate_sad(yaml_path: Path, output_path: Path):
    """Generate SAD.md from architecture.yaml"""
    
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)
    
    lines = [
        "<!-- AUTO-GENERATED from architecture.yaml -->",
        "<!-- Do not edit this file directly. Edit architecture.yaml and run: python scripts/generate_docs.py -->",
        "",
        "# System Architecture Document (SAD)",
        "",
        "## High-Level Architecture",
        "",
        "```",
        "+-------------------+",
        "|   User Workload   |",
        "|  (PyTorch App)    |",
        "+-------------------+",
        "        |",
        "        | (NVTX markers, Python hooks)",
        "        v",
        "+-------------------+",
        "| Trace Collectors  |",
        "+-------------------+",
        "        |",
        "        +---> CPU Collector (Python profiler + sys.settrace)",
        "        |",
        "        +---> GPU Collector (CUPTI)",
        "        |",
        "        +---> Memory Collector (procfs, NUMA APIs)",
        "        |",
        "        v",
        "+-------------------+",
        "| Timeline Merger   |",
        "|  - clock sync     |",
        "|  - event ordering |",
        "+-------------------+",
        "        |",
        "        v",
        "+-------------------+",
        "| Analyzer Engine   |",
        "|  - bottlenecks    |",
        "|  - root causes    |",
        "|  - suggestions    |",
        "+-------------------+",
        "        |",
        "        v",
        "+-------------------+",
        "| Report Generator  |",
        "|  - Markdown/HTML  |",
        "+-------------------+",
        "```",
        "",
        "## Component Responsibilities",
        ""
    ]
    
    components = data.get('components', {})
    for comp_name in sorted(components.keys()):
        comp = components[comp_name]
        lines.append(f"### {comp_name}")
        lines.append(f"- **Responsibility**: {comp['responsibility']}")
        
        if 'technology' in comp:
            lines.append(f"- **Technology**: {comp['technology']}")
        
        if 'concurrency_model' in comp:
            lines.append(f"- **Concurrency**: {comp['concurrency_model']}")
        
        if 'interfaces' in comp:
            lines.append("- **Interfaces**:")
            for iface in comp['interfaces']:
                lines.append(f"  - {iface}")
        
        lines.append("")
    
    lines.extend([
        "## Design Principles",
        "1. **Composability**: Each component is independent and testable",
        "2. **Observability**: Every operation is logged and traceable",
        "3. **Correctness**: All timings are verified and cross-checked",
        "4. **Clarity**: Reports explain causes, not just statistics",
    ])
    
    output_path.write_text('\n'.join(lines) + '\n')
    print(f"✓ Generated {output_path.name} from {yaml_path.name}")


def generate_icd(yaml_path: Path, output_path: Path):
    """Generate ICD.md from interfaces.yaml"""
    
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)
    
    lines = [
        "<!-- AUTO-GENERATED from interfaces.yaml -->",
        "<!-- Do not edit this file directly. Edit interfaces.yaml and run: python scripts/generate_docs.py -->",
        "",
        "# Interface Control Document (ICD)",
        "",
        "## Overview",
        "This document defines all inter-module APIs, data formats, and communication contracts for InferScope.",
        "",
    ]
    
    if 'python_api' in data:
        lines.extend([
            "## Python API (User-Facing)",
            ""
        ])
        
        for api_name, api_spec in data['python_api'].items():
            lines.append(f"### {api_name}()")
            lines.append("")
            lines.append(f"**Description:** {api_spec['description']}")
            lines.append("")
            
            lines.append("**Signature:**")
            lines.append("```python")
            lines.append(api_spec['signature'])
            lines.append("```")
            lines.append("")
            
            if 'parameters' in api_spec:
                lines.append("**Parameters:**")
                for param, desc in api_spec['parameters'].items():
                    lines.append(f"- `{param}`: {desc}")
                lines.append("")
            
            if 'returns' in api_spec:
                lines.append("**Returns:**")
                lines.append(f"- {api_spec['returns']}")
                lines.append("")
            
            if 'example' in api_spec:
                lines.append("**Example:**")
                lines.append("```python")
                for example_line in api_spec['example']:
                    lines.append(example_line)
                lines.append("```")
                lines.append("")
    
    if 'trace_format' in data:
        lines.extend([
            "## Trace Format (Internal)",
            "",
            "### Event Schema",
            ""
        ])
        
        schema = data['trace_format']['event_schema']
        lines.append("```json")
        lines.append("{")
        for field, field_spec in schema.items():
            lines.append(f"  \"{field}\": \"{field_spec['type']}  // {field_spec['description']}\",")
        lines.append("}")
        lines.append("```")
        lines.append("")
    
    output_path.write_text('\n'.join(lines) + '\n')
    print(f"✓ Generated {output_path.name} from {yaml_path.name}")


def main():
    repo_root = Path(__file__).parent.parent
    
    # Generate PRD
    prd_yaml = repo_root / 'docs' / '1_requirements' / 'requirements.yaml'
    prd_output = repo_root / 'docs' / '1_requirements' / 'PRD.md'
    
    if prd_yaml.exists():
        generate_prd(prd_yaml, prd_output)
    else:
        print(f"⚠ Skipped PRD: {prd_yaml} not found")
    
    # Generate SAD
    sad_yaml = repo_root / 'docs' / '2_system_architecture' / 'architecture.yaml'
    sad_output = repo_root / 'docs' / '2_system_architecture' / 'SAD.md'
    
    if sad_yaml.exists():
        generate_sad(sad_yaml, sad_output)
    else:
        print(f"⚠ Skipped SAD: {sad_yaml} not found")
    
    # Generate ICD
    icd_yaml = repo_root / 'docs' / '3_module_design' / 'interfaces.yaml'
    icd_output = repo_root / 'docs' / '3_module_design' / 'ICD.md'
    
    if icd_yaml.exists():
        generate_icd(icd_yaml, icd_output)
    else:
        print(f"⚠ Skipped ICD: {icd_yaml} not found")


if __name__ == '__main__':
    main()
