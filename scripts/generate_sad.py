#!/usr/bin/env python3
"""
Generate SAD.md from architecture.yaml

This script reads the machine-readable architecture.yaml and generates
a human-readable SAD.md (System Architecture Document) file.

Usage:
    python scripts/generate_sad.py
"""

import yaml
from pathlib import Path


def generate_sad(yaml_path: Path, output_path: Path):
    """Generate SAD.md from architecture.yaml"""
    
    # Read YAML
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)
    
    # Start building Markdown
    lines = [
        "<!-- AUTO-GENERATED from architecture.yaml -->",
        "<!-- Do not edit this file directly. Edit architecture.yaml and run: python scripts/generate_sad.py -->",
        "",
        "# System Architecture Document (SAD)",
        "",
        "## High-Level Architecture",
        "",
        "```",
        "+-------------------+",
        "|   User Workload   |",
        "|  (PyTorch App)    |",
        "+-------------------+",
        "        |",
        "        | (NVTX markers, Python hooks)",
        "        v",
        "+-------------------+",
        "| Trace Collectors  |",
        "+-------------------+",
        "        |",
        "        +---> CPU Collector (Python profiler + sys.settrace)",
        "        |",
        "        +---> GPU Collector (CUPTI)",
        "        |",
        "        +---> Memory Collector (procfs, NUMA APIs)",
        "        |",
        "        v",
        "+-------------------+",
        "| Trace Buffer      |",
        "| (Ring Buffer)     |",
        "+-------------------+",
        "        |",
        "        v",
        "+-------------------+",
        "| Timeline Merger   |",
        "| (Clock sync +     |",
        "|  Event ordering)  |",
        "+-------------------+",
        "        |",
        "        v",
        "+-------------------+",
        "| Analyzer Engine   |",
        "| (Bottleneck rules)|",
        "+-------------------+",
        "        |",
        "        v",
        "+-------------------+",
        "| Report Generator  |",
        "| (Markdown/HTML)   |",
        "+-------------------+",
        "        |",
        "        v",
        "+-------------------+",
        "|   Output Report   |",
        "+-------------------+",
        "```",
        "",
        "## Component Responsibilities",
        ""
    ]
    
    # Add components
    components = data.get('components', {})
    for i, (comp_id, comp) in enumerate(sorted(components.items()), 1):
        # Convert snake_case to Title Case
        title = comp_id.replace('_', ' ').title()
        
        lines.append(f"### {i}. {title}")
        lines.append(f"- **Responsibility**: {comp['responsibility']}")
        
        # Add technology if present
        if 'technology' in comp:
            lines.append(f"- **Technology**: {comp['technology']}")
        
        # Add interfaces if present
        if 'interfaces' in comp:
            interfaces_str = ", ".join(comp['interfaces'])
            lines.append(f"- **Interfaces**: {interfaces_str}")
        
        # Add concurrency model if present
        if 'concurrency_model' in comp:
            lines.append(f"- **Concurrency**: {comp['concurrency_model']}")
        
        # Add other specific fields
        if 'size_default_mb' in comp:
            lines.append(f"- **Default Size**: {comp['size_default_mb']} MB")
        if 'overflow_behavior' in comp:
            lines.append(f"- **Overflow Behavior**: {comp['overflow_behavior']}")
        if 'accuracy' in comp:
            lines.append(f"- **Accuracy**: {comp['accuracy']}")
        if 'rules' in comp:
            lines.append("- **Rules**:")
            for rule in comp['rules']:
                lines.append(f"  - {rule}")
        if 'formats' in comp:
            formats_str = ", ".join(comp['formats'])
            lines.append(f"- **Output Formats**: {formats_str}")
        
        lines.append("")
    
    # Add data flow section
    lines.extend([
        "## Data Flow",
        "",
        "1. **Collection Phase** (parallel):",
        "   - CPU events → CPU Collector → Trace Buffer",
        "   - GPU events → GPU Collector → Trace Buffer",
        "   - Memory events → Memory Collector → Trace Buffer",
        "",
        "2. **Merger Phase** (sequential):",
        "   - Read all events from Trace Buffer",
        "   - Synchronize clocks",
        "   - Sort by global timestamp",
        "   - Output unified timeline",
        "",
        "3. **Analysis Phase** (sequential):",
        "   - Apply bottleneck rules to timeline",
        "   - Classify idle periods, transfers, compute",
        "   - Generate root cause analysis",
        "",
        "4. **Reporting Phase** (sequential):",
        "   - Format timeline for report",
        "   - Render statistics and suggestions",
        "   - Output Markdown/HTML",
        "",
    ])
    
    # Add external interfaces
    lines.extend([
        "## External Interfaces",
        ""
    ])
    
    ext_interfaces = data.get('external_interfaces', {})
    
    # Python API
    if 'python_api' in ext_interfaces:
        lines.append("### Python API")
        lines.append("```python")
        lines.append("from inferscope import scope")
        lines.append("")
        lines.append("with scope(\"inference_step\"):")
        lines.append("    output = model.forward(inputs)")
        lines.append("```")
        lines.append("")
    
    # CLI
    if 'cli' in ext_interfaces:
        lines.append("### CLI Interface")
        lines.append("```bash")
        for cmd in ext_interfaces['cli']:
            lines.append(cmd)
        lines.append("```")
        lines.append("")
    
    # Configuration
    if 'config' in ext_interfaces:
        lines.append("### Configuration")
        config = ext_interfaces['config']
        if 'sources' in config:
            sources_str = " > ".join(config['sources'])
            lines.append(f"- **Precedence**: {sources_str}")
        if 'example_vars' in config:
            lines.append("- **Environment Variables**:")
            for var in config['example_vars']:
                lines.append(f"  - `{var}`")
        lines.append("")
    
    # Add threading model
    lines.extend([
        "## Threading & Concurrency Model",
        ""
    ])
    
    # Extract concurrency info from components
    for comp_id, comp in sorted(components.items()):
        if 'concurrency_model' in comp:
            title = comp_id.replace('_', ' ').title()
            lines.append(f"- **{title}**: {comp['concurrency_model']}")
    
    lines.append("")
    
    # Add failure modes section (template)
    lines.extend([
        "## Failure Modes & Mitigations",
        "",
        "| Failure | Mitigation |",
        "|---------|-----------|",
        "| CUDA initialization fails | Fallback to CPU-only analysis |",
        "| CUPTI unavailable | Graceful degradation: warn + CPU-only |",
        "| Trace buffer overflow | Ring buffer wraps; oldest events discarded |",
        "| Clock sync error | Use conservative sync margin; report uncertainty |",
        "| Memory pressure | Emit warning; reduce buffer size |",
    ])
    
    # Write to file
    output_path.write_text('\n'.join(lines) + '\n')
    print(f"✓ Generated {output_path} from {yaml_path}")


if __name__ == '__main__':
    # Paths relative to repository root
    repo_root = Path(__file__).parent.parent
    yaml_path = repo_root / 'Doc' / '2_system_architecture' / 'architecture.yaml'
    output_path = repo_root / 'Doc' / '2_system_architecture' / 'SAD.md'
    
    if not yaml_path.exists():
        print(f"Error: {yaml_path} not found")
        exit(1)
    
    generate_sad(yaml_path, output_path)
